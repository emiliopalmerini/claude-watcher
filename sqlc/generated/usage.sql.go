// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: usage.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createUsageLimit = `-- name: CreateUsageLimit :exec
INSERT INTO usage_limits (id, limit_value, warn_threshold, enabled, updated_at)
VALUES (?, ?, ?, ?, datetime('now'))
ON CONFLICT (id) DO UPDATE SET
    limit_value = excluded.limit_value,
    warn_threshold = excluded.warn_threshold,
    enabled = excluded.enabled,
    updated_at = datetime('now')
`

type CreateUsageLimitParams struct {
	ID            string          `json:"id"`
	LimitValue    float64         `json:"limit_value"`
	WarnThreshold sql.NullFloat64 `json:"warn_threshold"`
	Enabled       int64           `json:"enabled"`
}

func (q *Queries) CreateUsageLimit(ctx context.Context, arg CreateUsageLimitParams) error {
	_, err := q.db.ExecContext(ctx, createUsageLimit,
		arg.ID,
		arg.LimitValue,
		arg.WarnThreshold,
		arg.Enabled,
	)
	return err
}

const deleteUsageLimit = `-- name: DeleteUsageLimit :exec
DELETE FROM usage_limits WHERE id = ?
`

func (q *Queries) DeleteUsageLimit(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteUsageLimit, id)
	return err
}

const getPlanConfig = `-- name: GetPlanConfig :one
SELECT id, plan_type, window_hours, learned_token_limit, learned_at, created_at, updated_at FROM plan_config WHERE id = 1
`

func (q *Queries) GetPlanConfig(ctx context.Context) (PlanConfig, error) {
	row := q.db.QueryRowContext(ctx, getPlanConfig)
	var i PlanConfig
	err := row.Scan(
		&i.ID,
		&i.PlanType,
		&i.WindowHours,
		&i.LearnedTokenLimit,
		&i.LearnedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRollingWindowUsage = `-- name: GetRollingWindowUsage :one
SELECT
    CAST(COALESCE(SUM(m.token_cache_read + m.token_cache_write), 0) AS REAL) as total_tokens,
    CAST(COALESCE(SUM(m.cost_estimate_usd), 0) AS REAL) as total_cost
FROM sessions s
JOIN session_metrics m ON s.id = m.session_id
WHERE datetime(s.started_at) >= datetime('now', ? || ' hours')
`

type GetRollingWindowUsageRow struct {
	TotalTokens float64 `json:"total_tokens"`
	TotalCost   float64 `json:"total_cost"`
}

func (q *Queries) GetRollingWindowUsage(ctx context.Context, dollar_1 sql.NullString) (GetRollingWindowUsageRow, error) {
	row := q.db.QueryRowContext(ctx, getRollingWindowUsage, dollar_1)
	var i GetRollingWindowUsageRow
	err := row.Scan(&i.TotalTokens, &i.TotalCost)
	return i, err
}

const getUsageLimit = `-- name: GetUsageLimit :one
SELECT id, limit_value, warn_threshold, enabled, created_at, updated_at FROM usage_limits WHERE id = ?
`

func (q *Queries) GetUsageLimit(ctx context.Context, id string) (UsageLimit, error) {
	row := q.db.QueryRowContext(ctx, getUsageLimit, id)
	var i UsageLimit
	err := row.Scan(
		&i.ID,
		&i.LimitValue,
		&i.WarnThreshold,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listUsageLimits = `-- name: ListUsageLimits :many
SELECT id, limit_value, warn_threshold, enabled, created_at, updated_at FROM usage_limits ORDER BY id
`

func (q *Queries) ListUsageLimits(ctx context.Context) ([]UsageLimit, error) {
	rows, err := q.db.QueryContext(ctx, listUsageLimits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UsageLimit{}
	for rows.Next() {
		var i UsageLimit
		if err := rows.Scan(
			&i.ID,
			&i.LimitValue,
			&i.WarnThreshold,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLearnedLimit = `-- name: UpdateLearnedLimit :exec
UPDATE plan_config
SET learned_token_limit = ?, learned_at = datetime('now'), updated_at = datetime('now')
WHERE id = 1
`

func (q *Queries) UpdateLearnedLimit(ctx context.Context, learnedTokenLimit sql.NullFloat64) error {
	_, err := q.db.ExecContext(ctx, updateLearnedLimit, learnedTokenLimit)
	return err
}

const upsertPlanConfig = `-- name: UpsertPlanConfig :exec
INSERT INTO plan_config (id, plan_type, window_hours, learned_token_limit, learned_at, updated_at)
VALUES (1, ?, ?, ?, ?, datetime('now'))
ON CONFLICT (id) DO UPDATE SET
    plan_type = excluded.plan_type,
    window_hours = excluded.window_hours,
    learned_token_limit = excluded.learned_token_limit,
    learned_at = excluded.learned_at,
    updated_at = datetime('now')
`

type UpsertPlanConfigParams struct {
	PlanType          string          `json:"plan_type"`
	WindowHours       int64           `json:"window_hours"`
	LearnedTokenLimit sql.NullFloat64 `json:"learned_token_limit"`
	LearnedAt         sql.NullString  `json:"learned_at"`
}

func (q *Queries) UpsertPlanConfig(ctx context.Context, arg UpsertPlanConfigParams) error {
	_, err := q.db.ExecContext(ctx, upsertPlanConfig,
		arg.PlanType,
		arg.WindowHours,
		arg.LearnedTokenLimit,
		arg.LearnedAt,
	)
	return err
}
